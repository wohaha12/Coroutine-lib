# 协程调度器实现

## 项目介绍

本项目实现了一个C++17协程调度器，支持多线程环境下的协程任务调度。调度器可以管理线程池，并将协程任务分配到不同线程上执行，提高程序的并发性能。

## 核心功能

- 多线程调度器：支持配置线程池大小
- 主线程复用：可选择是否将调用者线程也作为工作线程
- 线程亲和性：支持指定任务在特定线程上执行
- 协程任务管理：支持协程和回调函数两种任务形式
- 任务队列：线程安全的任务队列管理

## 项目结构

- `scheduler.h`：调度器类的定义和接口
- `scheduler.cpp`：调度器的具体实现
- `main.cpp`：示例程序，展示调度器的使用方法
- `fiber.h/cpp`：协程实现（由父目录提供）
- `thread.h/cpp`：线程封装（由父目录提供）

## 编译说明

使用以下命令编译示例程序：

```bash
g++ *.cpp -std=c++17 -o test
```

## 调试开关

- 在`scheduler.cpp`中可以通过定义`DEBUG`宏来开启或关闭调试信息
- 定义`DEBUG`宏将输出详细的调试信息
- 注释掉`DEBUG`宏将关闭调试信息

## 类和API说明

### Scheduler类

#### 构造函数

```cpp
Scheduler(size_t threads = 1, bool use_caller = true, const std::string& name="Scheduler");
```
- `threads`：线程池大小（额外创建的线程数）
- `use_caller`：是否将调用者线程也作为工作线程
- `name`：调度器名称

#### 核心方法

- `start()`：启动线程池，创建并启动所有工作线程
- `stop()`：停止调度器，等待所有任务完成并停止工作线程
- `scheduleLock(FiberOrCb fc, int thread = -1)`：添加任务到任务队列（线程安全）
  - `fc`：任务对象，可以是协程指针或回调函数
  - `thread`：指定任务执行的线程ID，-1表示任意线程

#### 示例用法

```cpp
// 创建一个有4个额外工作线程的调度器，使用主线程作为工作线程
Scheduler scheduler(4);

// 启动调度器
scheduler.start();

// 添加任务到调度器
scheduler.scheduleLock([]{ /* 任务代码 */ });

// 停止调度器
scheduler.stop();
```

## 工作原理

1. **任务调度**：调度器维护一个线程安全的任务队列，工作线程从队列中获取任务并执行
2. **空闲处理**：当没有任务时，工作线程执行idle协程，定期让出CPU
3. **线程同步**：使用互斥锁保护任务队列，使用atomic变量跟踪线程状态
4. **调度控制**：通过tickle机制通知工作线程有新任务到达

## 注意事项

- 调度器支持两种任务形式：协程指针和回调函数
- 可以通过指定线程ID来控制任务在特定线程上执行
- 当调度器停止时，会等待所有任务完成后才会退出
- 使用协程让出CPU时，会回到调度器的run函数继续获取下一个任务

## 性能考虑

- 使用线程池避免了频繁创建和销毁线程的开销
- 任务队列设计考虑了线程安全性和性能平衡
- 支持线程亲和性，可以更好地利用CPU缓存
- idle协程的实现避免了忙等待，减少CPU使用率