# IOManager - 协程IO管理器

## 项目概述
本项目实现了一个基于协程的IO管理器（IOManager），它是一个高性能的事件驱动框架核心组件。IOManager结合了协程调度和IO事件监听，能够高效处理大量并发IO操作，适用于网络服务器、代理、爬虫等需要处理高并发IO的场景。

## 实现目的
1. **提高IO密集型应用性能**：通过非阻塞IO和协程调度，避免传统多线程模型中的线程切换开销和阻塞等待问题
2. **简化异步编程模型**：使用协程使得异步代码可以像同步代码一样编写，提高开发效率和代码可读性
3. **支持高并发处理**：单线程可以管理成千上万的连接，突破传统线程模型的并发瓶颈
4. **集成定时器功能**：提供定时任务调度能力，支持超时处理等场景

## 实现方法

### 核心设计
1. **继承关系**：
   - `IOManager` 继承自 `Scheduler`（协程调度器）和 `TimerManager`（定时器管理器）
   - 同时具备协程调度和IO事件管理能力

2. **事件驱动机制**：
   - 基于Linux `epoll` 实现IO事件监听
   - 支持READ（读）和WRITE（写）两种基本事件类型

3. **文件描述符管理**：
   - 使用 `FdContext` 结构体管理每个文件描述符的状态和回调
   - 为每个文件描述符维护读写事件的上下文信息

4. **工作流程**：
   ```
   1. 注册IO事件 -> 2. 等待事件就绪 -> 3. 调度回调函数/协程 -> 4. 注销事件 -> 5. 执行回调
   ```

### 关键组件

1. **IOManager类**：
   - 管理工作线程池
   - 维护epoll实例和文件描述符上下文
   - 提供事件注册、删除、取消等接口

2. **FdContext结构体**：
   - 存储文件描述符的状态信息
   - 管理读写事件的回调函数或协程

3. **EventContext结构体**：
   - 存储单个事件的回调信息
   - 支持协程回调和函数回调两种方式

### 核心方法

1. **addEvent**：注册IO事件，关联文件描述符和回调函数
2. **delEvent**：删除注册的IO事件
3. **cancelEvent**：取消IO事件并触发回调
4. **cancelAll**：取消文件描述符上的所有事件
5. **idle**：空闲线程等待IO事件的核心函数
6. **tickle**：唤醒等待中的线程

## 使用方法

### 基本用法

1. **创建IO管理器实例**：
```cpp
// 创建IO管理器，2个工作线程
IOManager manager(2);
```

2. **注册IO事件**：
```cpp
// 方式1：使用回调函数
manager.addEvent(fd, IOManager::READ, []() {
    // 处理读事件
});

// 方式2：使用协程（当前协程将被挂起，事件就绪时恢复执行）
manager.addEvent(fd, IOManager::WRITE);
```

3. **删除或取消事件**：
```cpp
// 删除事件但不触发回调
manager.delEvent(fd, IOManager::READ);

// 取消事件并触发回调
manager.cancelEvent(fd, IOManager::WRITE);

// 取消所有事件并触发回调
manager.cancelAll(fd);
```

### 注意事项

1. 确保在IO事件处理完成前，程序不会退出
2. 文件描述符必须设置为非阻塞模式
3. 适当管理文件描述符资源，避免泄漏

## 测试方法

### 编译项目

```bash
g++ *.cpp -std=c++17 -o test
```

### 运行测试

```bash
./test
```

### 测试说明

main.cpp中的测试程序演示了：
1. 创建IO管理器实例
2. 建立非阻塞TCP连接
3. 注册写事件发送HTTP请求
4. 注册读事件接收响应
5. 处理响应数据

测试过程会连接到指定的HTTP服务器（示例中为http://110.242.68.66:80），发送GET请求并接收响应。

## 调试信息

可以在ioscheduler.cpp中开启/关闭debug信息，便于调试和理解程序执行流程。

## 性能特性

1. **低延迟**：协程切换开销远低于线程切换
2. **高并发**：单线程可管理数万连接
3. **内存高效**：每个协程占用的内存远小于线程
4. **非阻塞IO**：充分利用系统调用的非阻塞特性
