// -----------------------------------------------------------------------------
// 文件名: main.cpp
// 描述: 使用epoll实现的高并发非阻塞HTTP服务器示例
// 功能: 展示如何使用Linux epoll机制实现事件驱动的非阻塞I/O服务器
// 作者: Auto-generated
// 创建日期: 2024
// -----------------------------------------------------------------------------

// =============================================================================
// 基于epoll的非阻塞HTTP服务器实现
// 本文件实现了一个使用Linux epoll机制的简单非阻塞HTTP服务器
// 该服务器能够处理多个并发连接，展示了事件驱动的编程模型
// =============================================================================

#include <stdio.h>      // 标准输入输出库，用于错误输出
#include <stdlib.h>     // 标准库，提供内存分配等功能
#include <string.h>     // 字符串处理库，用于内存操作和字符串函数
#include <unistd.h>     // Unix标准库，提供close、read、write等系统调用
#include <sys/socket.h> // 套接字API，提供socket、bind、listen、accept等函数
#include <arpa/inet.h>  // 提供IP地址转换功能，如htons、INADDR_ANY等
#include <sys/epoll.h>  // epoll相关函数和数据结构定义

// 定义epoll能够处理的最大事件数量
#define MAX_EVENTS 10
// 定义服务器监听端口
#define PORT 8888

// =============================================================================
// 主函数入口
// 实现了基于epoll的HTTP服务器的核心逻辑
// =============================================================================
int main() {
    // 文件描述符变量定义
    int listen_fd;    // 监听套接字文件描述符
    int conn_fd;      // 客户端连接套接字文件描述符
    int epoll_fd;     // epoll实例文件描述符
    int event_count;  // epoll_wait返回的事件数量
    
    // 网络地址结构
    struct sockaddr_in server_addr; // 服务器地址结构
    struct sockaddr_in client_addr; // 客户端地址结构
    socklen_t addr_len = sizeof(client_addr); // 地址长度
    
    // epoll事件相关结构
    struct epoll_event events[MAX_EVENTS]; // 用于存储epoll_wait返回的事件
    struct epoll_event event;             // 用于注册到epoll的事件结构

    // =========================================================================
    // 创建TCP监听套接字
    // AF_INET: IPv4协议族
    // SOCK_STREAM: 面向连接的套接字（TCP）
    // 0: 使用默认的TCP协议
    // =========================================================================
    if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");  // 输出错误信息
        return -1;         // 失败返回
    }

    // =========================================================================
    // 设置套接字选项
    // SO_REUSEADDR: 允许地址重用，解决 "address already in use" 错误
    // 这在服务器重启时特别有用，可以立即绑定到之前使用的端口
    // =========================================================================
    int yes = 1;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

    // =========================================================================
    // 初始化并配置服务器地址结构
    // memset: 清零地址结构体
    // sin_family: 设置为IPv4协议族
    // sin_port: 设置端口号，htons将主机字节序转换为网络字节序
    // sin_addr.s_addr: 设置为INADDR_ANY，表示监听所有网络接口
    // =========================================================================
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    // =========================================================================
    // 将监听套接字绑定到指定地址和端口
    // 将sockaddr_in转换为通用的sockaddr结构指针
    // =========================================================================
    if (bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        return -1;
    }

    // =========================================================================
    // 将套接字设置为监听模式
    // 1024: 最大连接队列长度，表示可以同时等待处理的连接数
    // =========================================================================
    if (listen(listen_fd, 1024) == -1) {
        perror("listen");
        return -1;
    }

    // =========================================================================
    // 创建epoll实例
    // epoll_create1: 创建一个epoll文件描述符
    // 参数0: 使用默认标志
    // =========================================================================
    if ((epoll_fd = epoll_create1(0)) == -1) {
        perror("epoll_create1");
        return -1;
    }

    // =========================================================================
    // 将监听套接字添加到epoll实例中进行事件监控
    // event.events = EPOLLIN: 监控可读事件（有新连接时触发）
    // event.data.fd: 存储文件描述符，用于事件触发时识别来源
    // epoll_ctl: 控制epoll实例中的事件
    // EPOLL_CTL_ADD: 添加事件
    // =========================================================================
    event.events = EPOLLIN;      // 监听可读事件
    event.data.fd = listen_fd;   // 关联监听套接字
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &event) == -1) {
        perror("epoll_ctl");
        return -1;
    }

    // =========================================================================
    // 主事件循环
    // 不断处理来自epoll的事件通知
    // =========================================================================
    while (1) {
        // =====================================================================
        // 等待事件发生
        // epoll_wait: 阻塞等待直到有事件发生或超时
        // 最后一个参数-1: 无限等待，直到有事件发生
        // 返回值: 就绪事件的数量
        // =====================================================================
        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (event_count == -1) {
            perror("epoll_wait");
            return -1;
        }

        // =====================================================================
        // 遍历所有就绪的事件并处理
        // =====================================================================
        // 遍历所有就绪的事件
        // =====================================================================
        for (int i = 0; i < event_count; i++) {
            // =================================================================
            // 处理监听套接字上的事件（新连接到达）
            // =================================================================
            if (events[i].data.fd == listen_fd) {
                // 接受新的客户端连接
                conn_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &addr_len);
                if (conn_fd == -1) {
                    perror("accept");
                    continue;  // 出错则跳过本次循环
                }

                // 将新连接的套接字添加到epoll中进行事件监控
                event.events = EPOLLIN;    // 监听可读事件
                event.data.fd = conn_fd;   // 关联新连接的套接字
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &event) == -1) {
                    perror("epoll_ctl");
                    return -1;
                }
            } else {
                // =================================================================
                // 处理客户端连接套接字上的事件（数据可读）
                // =================================================================
                char buf[1024];  // 接收缓冲区
                int len = read(events[i].data.fd, buf, sizeof(buf) - 1); // 读取数据
                if (len <= 0) {
                    // 发生错误或连接关闭，关闭连接
                    close(events[i].data.fd);
                } else {
                    // 确保缓冲区以null结尾
                    buf[len] = '\0';
                    
                    // =================================================================
                    // 发送HTTP响应
                    // 返回一个简单的HTTP 200 OK响应
                    // =================================================================
                    const char *response = "HTTP/1.1 200 OK\r\n"
                                           "Content-Type: text/plain\r\n"
                                           "Content-Length: 1\r\n"
                                           "Connection: keep-alive\r\n"
                                           "\r\n"
                                           "1";
                    write(events[i].data.fd, response, strlen(response));
                    
                    // =================================================================
                    // 从epoll中移除该文件描述符
                    // 注意：这里被注释掉了，如果取消注释，需要确保在close之前执行
                    // =================================================================
                    // epoll_ctl(epoll_fd,EPOLL_CTL_DEL,events[i].data.fd,NULL);
                    
                    // 关闭客户端连接
                    close(events[i].data.fd);
                }
            }
        }
    }

    // =========================================================================
    // 清理资源
    // 注意：在实际代码中，这个部分永远不会执行到，因为主循环是无限循环
    // =========================================================================
    close(listen_fd);  // 关闭监听套接字
    close(epoll_fd);   // 关闭epoll实例
    return 0;
}
