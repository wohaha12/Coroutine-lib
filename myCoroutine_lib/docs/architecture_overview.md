# 项目架构概述

## 1. 项目定位与设计目标

### 1.1 项目定位
mycoroutine 是一个基于 C++17 标准开发的高性能协程库，提供了完整的协程实现、调度器、IO 多路复用以及系统调用钩子机制。该库旨在简化异步编程模型，提高程序的并发处理能力和资源利用率，同时保持良好的易用性和可扩展性。

### 1.2 设计目标
- **高性能**: 采用高效的协程切换机制和 IO 多路复用技术，降低系统开销
- **易用性**: 提供简洁的 API 接口，支持透明的非阻塞 IO 操作
- **可扩展性**: 模块化设计，支持自定义调度策略和扩展功能
- **稳定性**: 完善的错误处理和资源管理机制
- **兼容性**: 支持多种 Linux 发行版，基于标准 C++17 实现

## 2. 整体架构设计

### 2.1 架构层次图

```
+---------------------------------------------------+
|                     应用层                         |
+---------------------------------------------------+
|  +-----------------+  +-----------------------+  |
|  |   协程 API       |  |  系统调用 hook        |  |
|  +-----------------+  +-----------------------+  |
+---------------------------------------------------+
|                     核心层                         |
+---------------------------------------------------+
|  +-----------------+  +-----------------------+  |
|  |   协程核心 (Fiber)|  |  协程调度器 (Scheduler)|  |
|  +-----------------+  +-----------------------+  |
|  +-----------------+  +-----------------------+  |
|  |   IO 管理器 (IOManager)|  |  定时器 (Timer)   |  |
|  +-----------------+  +-----------------------+  |
+---------------------------------------------------+
|                     基础层                         |
+---------------------------------------------------+
|  +-----------------+  +-----------------------+  |
|  |   线程管理 (Thread)|  |  FD 管理器 (FDManager)|  |
|  +-----------------+  +-----------------------+  |
|  +-----------------+  +-----------------------+  |
|  |   工具库 (Utils) |  |  日志系统             |  |
|  +-----------------+  +-----------------------+  |
+---------------------------------------------------+
|                     系统层                         |
+---------------------------------------------------+
|  Linux 内核 |  Epoll |  Eventfd |  系统调用       |
+---------------------------------------------------+
```

### 2.2 核心模块关系

| 模块名称 | 主要职责 | 依赖关系 |
|---------|---------|---------|
| Fiber | 协程创建、切换、状态管理 | Thread、Utils |
| Scheduler | 协程调度、任务管理、线程池 | Fiber、Thread、Timer |
| IOManager | IO 事件处理、超时管理 | Scheduler、FDManager、Eventfd |
| Timer | 定时器实现、超时回调 | Utils |
| Thread | 线程创建、管理、同步 | Utils |
| FDManager | 文件描述符生命周期管理 | Timer |
| Hook | 系统调用拦截、透明非阻塞 | FDManager、IOManager |
| Utils | 日志系统、通用工具函数 | - |

## 3. 技术栈与依赖

### 3.1 编程语言与标准
- **编程语言**: C++17
- **编译工具**: GCC 7+ 或 Clang 6+
- **构建系统**: CMake 3.15+

### 3.2 核心技术

| 技术 | 用途 | 优势 |
|-----|-----|-----|
| 有栈协程 | 协程实现 | 高性能、低开销、易于实现 |
| Epoll | IO 多路复用 | 支持大量并发连接、高效事件处理 |
| Eventfd | 线程唤醒机制 | 比 pipe 更高效、占用资源更少 |
| 系统调用钩子 | 透明非阻塞 IO | 无需修改现有代码即可支持异步操作 |
| 红黑树 | 定时器管理 | 高效的插入和删除操作 |
| 线程池 | 任务并行执行 | 充分利用多核 CPU 资源 |

### 3.3 依赖关系
- **无外部依赖**: 纯 C++ 实现，仅依赖 Linux 系统调用和标准库
- **标准库依赖**: `thread`, `mutex`, `condition_variable`, `functional`, `chrono` 等

## 4. 设计原则与决策

### 4.1 设计原则
- **模块化设计**: 各模块职责清晰，低耦合高内聚
- **性能优先**: 优化关键路径，减少系统调用和内存分配
- **易用性**: 提供简洁的 API，降低使用门槛
- **可扩展性**: 支持自定义调度策略和扩展功能
- **安全性**: 完善的资源管理和错误处理机制

### 4.2 关键设计决策

#### 4.2.1 协程实现选择
- **选择**: 有栈协程
- **理由**: 实现简单高效，切换开销小，支持完整的函数调用栈
- **实现方式**: 使用 `ucontext` 或手工汇编实现协程切换

#### 4.2.2 IO 多路复用技术
- **选择**: Epoll
- **理由**: 支持水平触发和边缘触发，高效处理大量连接，Linux 原生支持
- **对比**: 比 select/poll 更适合高并发场景

#### 4.2.3 线程唤醒机制
- **选择**: Eventfd
- **理由**: 比传统的 pipe 机制更高效，占用更少的文件描述符
- **优势**: 单个 eventfd 可以唤醒多个线程，支持原子操作

#### 4.2.4 系统调用钩子实现
- **选择**: LD_PRELOAD 动态链接 + 函数重定向
- **理由**: 透明拦截系统调用，无需修改现有代码
- **支持的系统调用**: `read`, `write`, `accept`, `connect` 等

## 5. 核心流程分析

### 5.1 协程创建与运行流程

```
1. 用户创建协程对象 (Fiber::ptr)
2. 设置协程入口函数
3. 将协程添加到调度器的任务队列
4. 调度器选择空闲线程执行协程
5. 协程开始执行
6. 协程主动挂起或遇到 IO 阻塞
7. 协程状态切换为挂起，保存上下文
8. 调度器选择下一个就绪协程执行
9. 被挂起的协程在条件满足时被唤醒
10. 协程恢复执行，直到结束
```

### 5.2 IO 事件处理流程

```
1. 用户发起 IO 操作 (如 read)
2. Hook 拦截系统调用，检查文件描述符状态
3. 如果 IO 不可立即完成，将协程挂起
4. 向 Epoll 添加 IO 事件监听
5. 协程切换，执行其他任务
6. 当 IO 事件就绪时，Epoll 通知 IOManager
7. IOManager 唤醒对应的协程
8. 协程恢复执行，完成 IO 操作
```

### 5.3 定时器执行流程

```
1. 用户创建定时器，设置超时时间和回调函数
2. 定时器被添加到红黑树中
3. 调度器定期检查定时器是否超时
4. 当定时器超时时，将回调函数封装为协程
5. 将协程添加到任务队列
6. 调度器执行超时回调协程
```

## 6. 模块扩展与定制

### 6.1 自定义调度策略
- 继承 `Scheduler` 类，重写调度逻辑
- 支持优先级调度、公平调度等自定义策略

### 6.2 扩展 IO 多路复用器
- 支持自定义 IO 多路复用实现
- 可扩展支持 kqueue、poll 等其他多路复用技术

### 6.3 添加新的系统调用钩子
- 在 `hook.cpp` 中添加新的系统调用拦截函数
- 更新 FD 管理器以支持新的 IO 类型

## 7. 性能优化方向

1. **协程切换优化**: 进一步减少协程切换的开销
2. **内存管理优化**: 实现协程栈的复用机制
3. **IO 事件处理优化**: 减少 Epoll 调用次数，优化事件分发
4. **定时器精度优化**: 提高定时器的精度和效率
5. **减少锁竞争**: 优化线程同步机制，减少锁的持有时间

## 8. 总结

mycoroutine 协程库采用了模块化的设计架构，将协程核心、调度器、IO 管理、定时器等功能组件清晰分离，同时保持了良好的协同工作能力。通过使用高效的协程切换机制、IO 多路复用技术和系统调用钩子，该库能够提供高性能的并发处理能力，同时简化异步编程模型。

该架构设计具有良好的扩展性和可维护性，支持自定义调度策略和功能扩展，能够适应不同场景下的需求。未来可以进一步优化性能，扩展功能，支持更多的平台和应用场景。