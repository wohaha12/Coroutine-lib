// ============================================================================
// 定时器模块头文件
// 定义了Timer和TimerManager类的接口，用于实现高效的定时器管理功能
// 支持一次性定时器和循环定时器，以及条件定时器功能
// ============================================================================
#ifndef __MYCOROUTINE_TIMER_H__
#define __MYCOROUTINE_TIMER_H__

#include <memory>
#include <vector>
#include <set>
#include <shared_mutex>
#include <assert.h>
#include <functional>
#include <mutex>

namespace mycoroutine {

// 前向声明TimerManager类，避免循环依赖
class TimerManager;

// ============================================================================
// Timer类
// 表示单个定时器对象，包含定时器的超时时间、回调函数、循环标志等属性
// 以及定时器的取消、刷新、重置等操作方法
// ============================================================================
class Timer : public std::enable_shared_from_this<Timer> 
{
    // 友元声明，允许TimerManager访问Timer的私有成员
    friend class TimerManager;
public:
    // ========================================================================
    // 取消定时器
    // 从定时器管理器的时间堆中移除该定时器，并清空回调函数
    // @return 取消成功返回true，失败返回false
    // ========================================================================
    bool cancel();
    
    // ========================================================================
    // 刷新定时器
    // 将定时器的下一次超时时间调整为当前时间加上定时时间
    // @return 刷新成功返回true，失败返回false
    // ========================================================================
    bool refresh();
    
    // ========================================================================
    // 重设定时器
    // 修改定时器的超时时间，并可选择是否从当前时间开始计时
    // @param ms 新的超时时间（毫秒）
    // @param from_now 是否从当前时间开始计算超时时间
    // @return 重置成功返回true，失败返回false
    // ========================================================================
    bool reset(uint64_t ms, bool from_now);

private:
    // ========================================================================
    // 构造函数（私有，只能由TimerManager创建）
    // @param ms 超时时间（毫秒）
    // @param cb 超时回调函数
    // @param recurring 是否循环执行
    // @param manager 所属的定时器管理器
    // ========================================================================
    Timer(uint64_t ms, std::function<void()> cb, bool recurring, TimerManager* manager);
 
private:
    // 是否循环执行定时器
    bool m_recurring = false;
    // 超时时间（毫秒）
    uint64_t m_ms = 0;
    // 下一次超时的绝对时间点
    std::chrono::time_point<std::chrono::system_clock> m_next;
    // 超时时触发的回调函数
    std::function<void()> m_cb;
    // 管理此timer的管理器指针
    TimerManager* m_manager = nullptr;

private:
    // ========================================================================
    // 比较器结构体
    // 用于在std::set中保持定时器按超时时间排序
    // ========================================================================
    struct Comparator 
    {        
        // ====================================================================
        // 比较运算符
        // 比较两个定时器的下一次超时时间
        // @param lhs 左侧定时器
        // @param rhs 右侧定时器
        // @return 左侧定时器的超时时间早于右侧则返回true
        // ====================================================================
        bool operator()(const std::shared_ptr<Timer>& lhs, const std::shared_ptr<Timer>& rhs) const;
    };
};

// ============================================================================
// TimerManager类
// 定时器管理器，负责管理多个定时器，包括添加、删除、查询定时器
// 以及获取超时的定时器回调函数等功能
// 可以被子类继承以实现更高级的功能
// ============================================================================
class TimerManager 
{
    // 友元声明，允许Timer访问TimerManager的私有成员
    friend class Timer;
public:
    // ========================================================================
    // 构造函数
    // 初始化定时器管理器的成员变量
    // ========================================================================
    TimerManager();
    
    // ========================================================================
    // 析构函数
    // 虚析构函数，便于派生类正确析构
    // ========================================================================
    virtual ~TimerManager();

    // ========================================================================
    // 添加定时器
    // 创建并添加一个新的定时器到管理器中
    // @param ms 超时时间（毫秒）
    // @param cb 超时回调函数
    // @param recurring 是否循环执行，默认为false
    // @return 创建的定时器智能指针
    // ========================================================================
    std::shared_ptr<Timer> addTimer(uint64_t ms, std::function<void()> cb, bool recurring = false);

    // ========================================================================
    // 添加条件定时器
    // 创建一个带条件的定时器，当条件不再满足时不会执行回调
    // @param ms 超时时间（毫秒）
    // @param cb 超时回调函数
    // @param weak_cond 条件对象的弱引用
    // @param recurring 是否循环执行，默认为false
    // @return 创建的定时器智能指针
    // ========================================================================
    std::shared_ptr<Timer> addConditionTimer(uint64_t ms, std::function<void()> cb, 
                                             std::weak_ptr<void> weak_cond, bool recurring = false);

    // ========================================================================
    // 获取下一个定时器的超时时间
    // 计算距离下一个定时器超时还剩多少毫秒
    // @return 下一个定时器的剩余超时时间（毫秒），如果没有定时器则返回最大值
    // ========================================================================
    uint64_t getNextTimer();

    // ========================================================================
    // 获取所有过期的定时器回调函数
    // 查找所有已超时的定时器，并将其回调函数收集到cbs中
    // @param cbs 用于存储过期定时器回调函数的容器
    // ========================================================================
    void listExpiredCb(std::vector<std::function<void()>>& cbs);

    // ========================================================================
    // 判断管理器中是否有定时器
    // @return 有定时器返回true，否则返回false
    // ========================================================================
    bool hasTimer();

protected:
    // ========================================================================
    // 当定时器插入到堆顶时的回调
    // 虚函数，允许派生类重写以实现自定义行为（如唤醒等待的线程）
    // ========================================================================
    virtual void onTimerInsertedAtFront() {};

    // ========================================================================
    // 添加定时器（内部方法）
    // 将定时器添加到时间堆中，并在必要时唤醒等待线程
    // @param timer 要添加的定时器
    // ========================================================================
    void addTimer(std::shared_ptr<Timer> timer);

private:
    // ========================================================================
    // 检测系统时钟回退
    // 检查系统时间是否发生回退（可能由NTP校正或手动调整引起）
    // @return 系统时间回退返回true，否则返回false
    // ========================================================================
    bool detectClockRollover();

private:
    // 读写锁，保护定时器集合的并发访问
    std::shared_mutex m_mutex;
    // 定时器集合，使用set实现的最小堆，按超时时间排序
    std::set<std::shared_ptr<Timer>, Timer::Comparator> m_timers;
    // 标志位，指示在下次getNextTimer()执行前是否已触发过onTimerInsertedAtFront()
    bool m_tickled = false;
    // 上次检查系统时间是否回退的时间点
    std::chrono::time_point<std::chrono::system_clock> m_previouseTime;
};

} // namespace mycoroutine

#endif // __MYCOROUTINE_TIMER_H__